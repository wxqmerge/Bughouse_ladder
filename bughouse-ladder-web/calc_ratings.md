# Rating Calculation Documentation

## Overview

This document describes the VB6-inspired rating calculation system for the Bughouse Chess Ladder application. The system validates game results from the player-result table (matrix) before calculating player ratings.

## Workflow

### 1. Data Loading

- Game results are stored in the `gameResults` array for each player
- Each entry represents a round (31 rounds total)
- Format: `"Player1:Player2[Score]"` where Score is W/L/D/O

### 2. Validation Phase

The `processGameResults()` function performs validation:

```typescript
const { matches, hasErrors, errorCount, errors } = processGameResults(
  players,
  31,
);
```

**Conflict Detection:**

The parser detects player-player conflicts by:

1. **Grouping results by player pair**: All results for the same match are tracked using a key like `"1-2"` for players 1 and 2
2. **Comparing result strings**: If Player 1 has `"1w2"` and Player 2 has `"1l2"`, these represent the same match but with different outcomes
3. **Flagging all conflicting entries**: When a conflict is detected, all entries for that match are marked as errors (error code 10)
4. **Example**:
   - John (rank 1): `"1w2"` = "I won against player 2"
   - Jane (rank 2): `"1l2"` = "Player 1 lost to player 2"
   - **Conflict**: These are the same match (1 vs 2) with contradictory results
   - **Result**: Both entries flagged as errors requiring correction

The conflict detection ensures data integrity by requiring both players to agree on match results before rating calculation proceeds.

**Validation Steps:**

1. Initialize hash table with `hashInitialize()`
2. Iterate through all players' `gameResults` array (rounds 0-30)
3. For each result string:
   - Call `string2long()` to parse and validate
   - Empty strings are skipped (not errors)
   - Invalid entries return negative hash value → counted as error
   - Valid entries added to hash table via `dataHash()`
4. Track results by player pair (e.g., "1-2" for players 1 and 2)
5. Detect conflicts when different players report different results for same match
6. Return `ProcessResult` with matches, errors, and error details

**Error Detection:**

- Invalid format (negative hash from `string2long`)
- Invalid player ranks (≤0 or >200)
- Missing player data
- **Player-player conflicts**: When two players have different result strings for the same match (e.g., John says "1w2" but Jane says "1l2")

### 3. Error Handling

If errors are detected (`hasErrors === true`):

1. Dialog opens showing first error with:
   - **First Player**: First player's first name
   - **Second Player**: Second player's first name
   - **Third Player** (4-player games): Third player's first name
   - **Fourth Player** (4-player games): Fourth player's first name
   - Original invalid string
   - Error message: "Conflicting results - players disagree on outcome" or "Invalid result format"
2. User can enter corrected result string
3. Correction is validated via `string2long()`
4. If valid, both players' `gameResults` updated with corrected string + "\_" suffix at the same resultIndex
5. User clicks "Continue with corrections" to proceed

### 4. Result Processing

**If no errors:**

1. Clear all `gameResults` arrays (set to null)
2. Repopulate from validated matches via `repopulateGameResults()`
3. Results are filled **sequentially from the left** (resultIndex 0, 1, 2, ...)
4. Each match result is written to both players' gameResults at the same index
5. Entries marked with "\_" suffix to indicate validated

**If errors were corrected:**

1. Uses player data updated during correction phase
2. Proceeds to rating calculation

### 5. Rating Calculation

The `calculateRatings()` function computes new ratings:

```typescript
const calculatedPlayers = calculateRatings(processedPlayers, matches);
```

**Algorithm:**

- Elo K-factor: 20 
- For each match:
  - Calculate expected score: `1 / (1 + 10^((|opponentRating| - |myRating|) / 400))`
  - Determine actual score: W=1, L=0, D=0.5
  - Update rating: `newRating = Math.round(oldRating + K * (actual - expected))`
  - Minimum rating: 0

## Data Structures

### ProcessResult

```typescript
interface ProcessResult {
  matches: MatchData[];
  hasErrors: boolean;
  errorCount: number;
  errors: ValidationResult[];
}
```

<<<<<<< HEAD
=======
### MatchData

```typescript
interface MatchData {
  player1: number; // Player 1 rank (1-200)
  player2: number; // Player 2 rank (1-200)
  player3: number; // Player 3 rank (1-200, -1 if not used)
  player4: number; // Player 4 rank (1-200, -1 if not used)
  score1: number; // Score for team 1 (0-4)
  score2: number; // Score for team 2 (0-4)
}
```
>>>>>>> d3e4606b58aeb9bb437e8e0188abc97580405d0e

### ValidationResult

```typescript
interface ValidationResult {
  hashValue: number;
  player1: number; // Player 1 rank
  player2: number; // Player 2 rank
  player3: number; // Player 3 rank (0 if not used)
  player4: number; // Player 4 rank (0 if not used)
  score1: number; // Score for team 1 (0-4)
  score2: number; // Score for team 2 (0-4)
  resultIndex: number; // Sequential result index (0-30)
  isValid: boolean;
  error: number;
  originalString: string;
}
```

## Hash Table

The hash table prevents duplicate match entries:

- **Key**: Computed hash value from `string2long()` + result index
- **Value**: Original result string
- **Capacity**: 2048 entries
- **Collision Resolution**: Linear probing

```typescript
const key = `${hashValue}_${resultIndex}`;
dataHash(key, result, 0);
```

## Result String Format

### Input Format

```
Player1:Player2[Score]
```


### Score Codes

- `W` - Win (score = 3)
- `L` - Loss (score = 1)
- `D` - Draw (score = 2)
- `O` - No result (score = 0)

### Validation Markers

After validation, entries are marked with underscore:

- Valid: `"10W20_"`
- This indicates the entry passed validation

## Functions

### processGameResults(players, numRounds)

Validates all game results and populates hash table.

**Parameters:**

- `players`: Array of PlayerData objects
- `numRounds`: Number of rounds (default: 31)

**Returns:** `ProcessResult` with matches and error details

### calculateRatings(players, matches)

Calculates Elo ratings based on match results.

**Parameters:**

- `players`: Array of PlayerData objects
- `matches`: Array of MatchData objects

**Returns:** Updated PlayerData array with `nRating` calculated

### repopulateGameResults(players, matches, numRounds)

Clears and repopulates game results from validated matches.

**Parameters:**

- `players`: Array of PlayerData objects
- `matches`: Array of MatchData objects
- `numRounds`: Number of rounds (default: 31)

**Returns:** Updated PlayerData array with cleared and repopulated results

## Integration

### Usage in LadderForm.tsx

```typescript
const recalculateRatings = () => {
  // Step 1: Validate all results
  const { matches, hasErrors, errorCount, errors } = processGameResults(
    players,
    31,
  );

  if (hasErrors && errors.length > 0) {
    // Step 2: Show error dialog for correction
    setPendingPlayers(players);
    setPendingMatches(matches);
    setCurrentError(errors[0]);
  } else {
    // Step 3: No errors - process directly
    const processedPlayers = repopulateGameResults(players, matches, 31);
    const calculatedPlayers = calculateRatings(processedPlayers, matches);
    setPlayers(calculatedPlayers);
    localStorage.setItem("ladder_players", JSON.stringify(calculatedPlayers));
  }
};
```
<<<<<<< HEAD
  
=======

### Error Correction Flow

```typescript
const handleCorrectionSubmit = (correctedString: string) => {
  // Validate corrected string
  const hashValue = string2long(
    correctedString,
    parsedPlayersList,
    parsedScoreList,
  );

  if (hashValue < 0) {
    alert(`Invalid format. Error code: ${Math.abs(hashValue)}`);
    return;
  }

  // Update both players' gameResults
  const updatedPlayers = pendingPlayers.map((p) => ({ ...p }));

  // Update player 1 at resultIndex
  if (player1Rank > 0 && player1Rank <= updatedPlayers.length) {
    const newGameResults = [...updatedPlayers[player1Rank - 1].gameResults];
    newGameResults[currentError.resultIndex] = correctedString + "_";
    updatedPlayers[player1Rank - 1].gameResults = newGameResults;
  }

  // Update player 2 at resultIndex
  if (player2Rank > 0 && player2Rank <= updatedPlayers.length) {
    const newGameResults = [...updatedPlayers[player2Rank - 1].gameResults];
    newGameResults[currentError.resultIndex] = correctedString + "_";
    updatedPlayers[player2Rank - 1].gameResults = newGameResults;
  }

  setPendingPlayers(updatedPlayers);
  setCurrentError(null);
};
```

### Parser Player Array Indices

The `string2long()` parser uses these array indices for player ranks:

```typescript
playersList[0] = Player 1 rank
playersList[1] = Player 2 rank
playersList[2] = (unused, reserved)
playersList[3] = Player 3 rank (4-player games)
playersList[4] = Player 4 rank (4-player games)
```

For 2-player games: `playersList[0]` and `playersList[1]` are set, `playersList[3]` and `playersList[4]` are 0.
For 4-player games: All four positions are set (e.g., `"1:2W3:4"` sets players 1, 2, 3, 4).

const completeRatingCalculation = () => {
const processedPlayers = repopulateGameResults(
pendingPlayers,
pendingMatches,
31,
);
const calculatedPlayers = calculateRatings(processedPlayers, pendingMatches);
setPlayers(calculatedPlayers);
localStorage.setItem("ladder_players", JSON.stringify(calculatedPlayers));
};

```

>>>>>>> d3e4606b58aeb9bb437e8e0188abc97580405d0e
## Error Codes

### From `string2long()` return values:

- `-1`: Invalid underscore placement
- `-2`: Invalid character
- `-3`: Invalid string length
- `-4`: Same player vs themselves
- `-7`: Invalid player 2 rank
- `-9`: Player rank exceeds maximum (200)

### From conflict detection:

- `10`: **Player-player conflict** - Two players report different results for the same match
  - Example: Player 1 says `"1w2"` (won) but Player 2 says `"1l2"` (lost)
  - Both entries are flagged as errors requiring user correction

## Notes

- Empty strings are silently skipped (not counted as errors)
- Hash table prevents duplicate match entries
- Only valid entries get "\_" suffix marker
- Rating calculation uses absolute values of ratings
- negative ratings mean not eligible for trophies
- Player ranks must be 1-200
<<<<<<< HEAD

=======
- Results are filled **sequentially from the left** (resultIndex 0, 1, 2, ...)
- Result index is independent of round number - results fill gameResults array sequentially
```
>>>>>>> d3e4606b58aeb9bb437e8e0188abc97580405d0e
